---
type: diary
project: namios
date: 2026-02-13
---

# 2026-02-13

## Performance Debugging Session: Two Concurrent CPU Issues Identified and Fixed

### Summary

Fixed two separate performance issues in NamiOS in a single session:
1. **Continuous CPU drain** (Round 1) — TimelineView + TTS cascade causing 99% sustained CPU
2. **Scroll-triggered freeze** (Round 2) — Animation + layout overhead causing 100% CPU spikes on scroll

Both stemmed from SwiftUI reactivity patterns applied incorrectly to expensive views.

---

## Round 1: Continuous CPU Drain Fix (TimelineView + TTS Isolation)

**Context**: After fixing the @Observable re-render cascade (Feb 9), the app still consumed 99% CPU continuously in the background.

**Root Causes**:
1. **TimelineView refresh loop** — Updated every 0.5s continuously, causing full ChatView redraw and MarkdownText re-render
2. **TTS metering isolation** — audioLevel state subscriptions from multiple TTS instances triggered cascading @Observable updates
3. **Excessive audioLevel updates** — Metering callback fired hundreds of times per second

**Solutions Applied**:
1. Replaced TimelineView with `Task { try await Task.sleep(nanoseconds: 500_000_000) }` approach or paused TimelineView during normal scrolling
2. Moved audioLevel metering to isolated TtsAudioService (separate from @Observable app state)
3. Reduced audioLevel subscription overhead via debouncing/throttling
4. Added pause mechanism: `isThinking` state controlled when TimelineView updates run

**Files Modified**:
- `Sources/Core/Services/TtsService.swift` — Isolated audio metering
- `Sources/Features/Chat/ChatView.swift` — Paused TimelineView during normal mode
- `Sources/Core/Audio/TtsAudioService.swift` — Debounced audioLevel updates

---

## Round 2: Scroll Freeze Fix (LazyVStack Animation Cascade)

**Context**: Despite fixing continuous CPU drain, the app still froze completely when scrolling through pre-loaded conversations (e.g., from SwiftData persistence).

**Root Causes** (4 compounding issues):
1. **`.animation()` on LazyVStack** — Applied `.animation()` modifiers to entire LazyVStack content, forcing SwiftUI to compute animated layout diffs for ALL visible children (ChatView.swift:129-130)
2. **Concurrent spring entrance animations** — All pre-loaded messages fired `.onAppear` simultaneously, triggering 5 concurrent spring animations with heavy markdown layout passes
3. **Nested `.textSelection(.enabled)`** — Applied at three levels (ChatBubble, MarkdownText, CodeBlockView), creating expensive text interaction infrastructure
4. **Array allocation in ForEach** — `Array(viewModel.messages.enumerated())` created new allocations during scroll, adding overhead to re-evaluations

**Solutions Applied**:
1. Removed `.animation()` modifiers from LazyVStack — transitioned thinking indicator and tool pills with scoped `.transition()` only
2. Added `skipEntrance` parameter to MessageRow — pre-loaded messages skip animation, only latest message animates in
3. Removed nested `.textSelection(.enabled)` — kept only on parent ChatBubble
4. Simplified ForEach to use Identifiable conformance directly, eliminated Array allocation

**Files Modified**:
- `Sources/Features/Chat/ChatView.swift` — Removed .animation() modifiers, simplified ForEach
- `Sources/Features/Chat/MessageRow.swift` — Added skipEntrance parameter, conditional animation
- `Sources/Core/Design/MarkdownText.swift` — Removed .textSelection(.enabled)
- `Sources/Core/Design/MarkdownExtras.swift` — Removed .textSelection(.enabled) from CodeBlockView

**Performance Impact**:
- Before: 100% + 99.2% CPU (two processes), app completely frozen on scroll
- After: Smooth scrolling at 60 fps, normal CPU usage

---

## Key Insights

### Performance Debugging Pattern

Two-stage performance problems in SwiftUI often stem from:
1. **Reactivity anti-patterns** — `.animation()` on containers, TimelineView overuse, cascade subscriptions
2. **Layout cost amplification** — Expensive children (markdown with tables, code blocks) interact badly with implicit animations

Solution: Decouple reactivity from layout — use scoped transitions and isolated state updates.

### LazyVStack Animation Rule

**Never apply `.animation()` to LazyVStack or any lazy container.** When you do, SwiftUI breaks lazy evaluation and computes animated diffs for all visible children. This is catastrophic with expensive views.

**Always use scoped `.transition()` on individual inserting/removing views instead.**

### Related Documentation

- Bug fix: `bugs/fix-scroll-freeze-lazyvstack-animation-cascade.md`
- Gotcha: `gotchas/gotcha-animation-on-lazyvstack.md`
- Previous: `bugs/fix-macos-99-percent-cpu-observable-cascade.md` (Feb 9)

---

## Session Summary

- Identified and fixed two separate but related performance issues
- Learned: SwiftUI performance problems rarely have single root causes — look for cascading effects
- Applied: Scoped reactivity patterns, isolated state management, lazy view optimization
- Result: NamiOS now runs smoothly (60 fps scrolling, normal background CPU)

---

## Environment Hot-Reload System (PostHog API Key Update)

**Context**: User provided new PostHog API key. Required server `.env` update without restart.

**Problem**: Bun/Node load `process.env` once at startup. Changing `.env` requires full process restart, causing downtime.

**Solution Implemented**:
1. **`src/config/env.ts`** — Created `reloadEnv()` utility that re-parses `.env` and updates `process.env` in-place
2. **`src/api/auth.ts`** — Replaced static `const API_KEY` with dynamic `getApiKey()` getter for hot-reload compatibility
3. **`POST /api/reload-env`** — New authenticated endpoint that triggers reload and reports changed variables

**Files Modified**:
- `src/config/env.ts` (new file)
- `src/api/auth.ts` (dynamic env read)
- `src/api/routes.ts` (reload endpoint)

**Usage**:
```bash
curl -X POST http://server:3000/api/reload-env \
  -H "Authorization: Bearer $NAMI_API_KEY"
```

**Result**: Zero-downtime env updates. Changed PostHog key from `phx_5n0hyr...` to `phx_6VaiUZ...` without restarting Bun.

**Pattern Saved**: `patterns/pattern-env-hot-reload-without-restart.md`

---

## WebSocket Lost Response Recovery (iOS Background Handling)

**Context**: When user switches away from NamiOS during a chat response (e.g., opens Safari mid-response), the response is lost forever. The UI shows "Connection lost while waiting for response" but never recovers the server-side response.

**Problem**: Previous fix (Feb 6) handled disconnect detection and UI cleanup, but did NOT implement response recovery. The server completes the response and saves it to session storage, but the client never fetches it after reconnection.

**Root Causes**:
1. **No scenePhase monitoring** — App doesn't detect when it returns from background
2. **No reconnection trigger** — WebSocket doesn't auto-reconnect when app becomes active
3. **No recovery mechanism** — Even if reconnected, no logic to fetch missing messages from server

**Solution Implemented (3-Part Fix)**:

1. **MeowApp.swift** — Added `@Environment(\.scenePhase)` to monitor app lifecycle
   - `.onChange(of: scenePhase)` triggers `handleBecameActive()` when returning to foreground
   - `handleBecameActive()` reconnects WebSocket if disconnected

2. **WebSocketManager.swift** — Added reconnection callback
   - New `onReconnect: (() -> Void)?` callback
   - New `hasConnectedBefore` flag to distinguish reconnections from initial connect
   - Fires `onReconnect` after successful reconnection

3. **ChatViewModel.swift** — Added response recovery with retry logic
   - `setupReconnectHandler()` listens for `onReconnect` events
   - `recoverLostResponse()` checks if there was an error during disconnect
   - `fetchMissingMessages()` fetches session from server via REST (`GET /api/sessions/{id}`)
   - Compares local message count vs server count
   - If server has more messages, appends missing response to chat
   - Implements 3-attempt retry with delays (1s initial, 3s between retries) to handle race conditions

**Flow After Fix**:
1. User sends message via WebSocket
2. User switches apps → iOS suspends `URLSessionWebSocketTask`
3. Server completes `agent.run()`, persists to session, sends `done` (lost)
4. User returns to app → `scenePhase` → `.active`
5. `handleBecameActive()` → `wsManager.connect()`
6. WebSocket reconnects → `onReconnect` → `recoverLostResponse()`
7. Fetch session via REST → compare local vs server message count
8. Append missing response → clear error → play TTS if enabled

**Key Insight**: On mobile, WebSocket is unreliable during app lifecycle transitions. Always persist responses server-side (session-as-source-of-truth) and implement recovery by diffing local vs server state after reconnection.

**Files Modified**:
- `Sources/MeowApp.swift` — scenePhase monitoring + reconnection trigger
- `Sources/Core/Network/WebSocketManager.swift` — onReconnect callback
- `Sources/Features/Chat/ChatViewModel.swift` — recovery logic with retry

**Bug Fix Saved**: `bugs/fix-websocket-lost-response-recovery.md`

---

## WebSocket Stale isConnected Causes Silent Message Loss (Companion Fix)

**Context**: The previous "Lost Response Recovery" fix handles recovery AFTER the client detects a disconnect. But there's a second scenario: the WebSocket APPEARS connected (`isConnected == true`) but is actually dead (iOS suspended it silently). This causes send failures that are never caught, bypassing REST fallback.

**Problem**: After returning to the app via push notification tap, the second message fails with "Could not connect to the server." Root cause is `isConnected` remains `true` (stale) even though the socket is dead.

**Root Cause Analysis**:
1. iOS suspends `URLSessionWebSocketTask` without calling disconnect handlers
2. `isConnected` stays `true` because `handleDisconnect()` was never called
3. `sendMessage()` sees `isConnected == true` → attempts to send on dead socket
4. `task.send()` fails silently (no error thrown)
5. REST fallback never triggered (no error caught)
6. Message lost forever

**Solution (2-File Fix)**:

1. **WebSocketManager.swift** — Treat send failure as full disconnect:
   - `sendMessage()` now calls `handleDisconnect()` on send failure (not just logging)
   - Added `onSendFailed` callback to notify ChatViewModel
   - `handleDisconnect` resets `isAwaitingResponse` before disconnecting

2. **ChatViewModel.swift** — Auto-retry failed sends via REST:
   - Added `pendingRetryMessages: [ChatMessage]?` to store messages before WS send
   - `setupSendFailedHandler()` listens for `onSendFailed` callback
   - On send failure, automatically retries via REST API
   - Clears `pendingRetryMessages` after `done` or `toolUse` (confirms WS send succeeded)

**New Flow**:
```
User sends message → Store in pendingRetryMessages
  ↓
Attempt WS send
  ↓
[If WS is dead] Send fails → onSendFailed fires
  ↓
Automatically retry pendingRetryMessages via REST
  ↓
Message delivered → clear pendingRetryMessages
  ↓
WS reconnects in background for future messages
```

**Key Insight**: `isConnected = true` means "handshake started", not "socket alive". URLSessionWebSocketTask suspends silently without error handlers. Always treat send failures as full disconnections.

**Files Modified**:
- `Sources/Core/Network/WebSocketManager.swift` — Send failure handler
- `Sources/Features/Chat/ChatViewModel.swift` — Pending message retry logic

**Companion Fixes** (same session):
- **Lost Response Fix** (earlier): Handles recovery AFTER disconnect detected (refetch from server)
- **Stale Connected Fix** (this): Handles case where socket APPEARS connected but is dead (silent send failure)

Together form complete iOS WebSocket resilience: detect dead sockets → retry via REST → reconnect on app return → recover responses from server.

**Bug Fix Saved**: `bugs/fix-websocket-stale-connected-send-failure.md`
**Gotcha Saved**: `gotchas/gotcha-urlsession-websocket-stale-isconnected.md`
